state_estimator {
  # when processing from log set 
  # false: republish_sensors, republish_cameras, publish_filter_state, gpf_vis, publish_diagnostics
  # true:  enable_at_launch (GPF), republish_incoming_poses (POSE_VICON & BDI)

  # when processing gpf:
  # init from vicon and ins but not pose_meas
  # use VICON_BODY when doing GPF from file
  # gpf_vis = false
  # additionally when running gpf out of process:
  # publish_filter_state=true
  # enable_at_launch = false

  # when running on robot use pose_meas to start from BDI Pose

  pose_channel = "POSE_BODY";
  filter_state_channel = "STATE_ESTIMATOR_STATE";
  # the frame at which to draw convariance information in viewer
  pose_render_frame = "body";

  publish_filter_state = true; #publish alongside pose
  publish_pose = true;
  republish_sensors = false; # make this false when not reading directly from a log

  # ins,vicon, pose_meas
  init_sensors = ["ins","pose_meas"];
  # laser_gpf, ins, rgbd_gpf, fovis, legodo , vicon, pose_meas
  active_sensors = ["ins","legodo"];

  # was this: 1000000 (1sec) for mav
  utime_history_span =1000000;

  #initial state estimate (relavent states overridden by init sensors)
  sigma0 {
          vb = 0.0; #m/s
          chi_xy = 3.0; #degrees
          chi_z = 3.0; #degrees
          Delta_xy = 0.05;#m
          Delta_z = 0.05;#m
          gyro_bias = 0; #deg/seg
          accel_bias = 0; #m/s^2 # 0.1 worked during tuning
  }

  ## typical atlas height
  x0 {
    velocity = [0,0,0];
    angular_velocity = [0,0,0];
    position = [0, 0, 0.45];
    rpy = [0, 0, 0];
  }

  init_message {
    channel = "MAV_STATE_EST_INITIALIZER";
  }

  viewer {
    channel = "MAV_STATE_EST_VIEWER_MEASUREMENT";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 1; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = true;
  }

  ins {
    channel ="ATLAS_IMU_BATCH";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 3; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = true;

    # microstrain: 0.5 | 0.2 | 0 | 0
    # i always used 0.5 | 0.2 | 0 | 0
    q_gyro = 0.5; #deg/sec
    q_accel = 0.2; #m/s^2
    q_gyro_bias = 0.02; #deg/seg^2 | 0.001 suggested by charlie, but not deemed to be necessary
    q_accel_bias = 0.0; #m/sec^2/sec | 0.001 suggested by charlie and worked well on logs
    frame = "imu";

    #ms
    #timestep_dt = 0.01; # REMEMBER TO CHANGE THIS IF YOU CHANGE THE IMU FREQUENCY or downsample factor
    #bdi
    timestep_dt = 0.003; # this is 1000/3=333.3R Hz - not 333Hz

    num_to_init = 1000; # was 100 for microstrain, was 333 for MIT before
    # attempt to detect drastically incorrect initial gyro biases estimates:
    max_initial_gyro_bias = 0.00015; # deg/sec, biases above this will be set to zero

    # apply notch filtering on input: (to atlas imu accel signals)
    atlas_filter = true;
    atlas_filter_freq = 87.0; # correct for after March 2014 work


    # Fine control of bias estimation
    # initial is a user specified bias vector
    # if (recalc) then estimate the bias again at launch
    # if (update) then allow biases to evolve
    gyro_bias_initial = [0,0,0];
    gyro_bias_recalc_at_start = true;
    gyro_bias_update_online = true;

    accel_bias_initial = [0,0,0];
    accel_bias_recalc_at_start = false;
    accel_bias_update_online = false;
  }

  # correct the pose to this value: (to init using Pose BDI)
  pose_meas{
    no_corrections = 100; # apply this number of corrections before going silent
    channel = "POSE_BDI";
    utime_offset = 0; #units 1e-6 seconds
    downsample_factor = 10; # process 1 out of every this many
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    r_xyz = .01; #m
    r_chi = 3.0; #degrees

    mode="position_orient"; # "position" "position_orient"
  }

  legodo {

    channel = "CORE_ROBOT_STATE";
    channel_force_torque = "FORCE_TORQUE";
    # lin_rate           linear velocities
    # lin_rot_rate       linear and rotation rates i.e. velocities
    # pos_and_lin_rate   position and linear velocities
    mode = "lin_rate";

    ##########################
    # [velocity] variances:
    # 0.5 the SE velocity tracks the kinematics - but too closely corrects to spikes
    #     when foot contacts occur the velocities spike. need to classify  (@333Hz)
    # 0.25 was what I used in later development  (@333Hz)
    # 0.1 is too low - the velocity corrections made wheren't physically possible.  (@333Hz)
    #     but when paired with lidar,  this worked well (@1kHz)
    # 1.5 paired with a position variance of 0.05m seemed to reduce position jerks in scott's controller transitions
    r_vxyz = 0.50;  # m/s
    r_vang  = 0.50;  # degrees?

    #### Variance for uncertain walking kinematics e.g. breaking and making contact
    # Setting equal to the above values makes this mode disabled
    # 0.75 and 1.00 worked well on batch processing
    r_vxyz_uncertain = 0.50;# 0.75;
    r_vang_uncertain = 0.50;# 1.00;

    ## Variance for Direct [Position] Measurement [NEW]
    # shared between modes
    # 1-2 looks good (with laser, at ~280Hz)
    # 4 twitch is beginning to appear (with laser)
    # 0.05m was useful (without laser), see above
    r_xyz = 2.0;
    ##########################

    utime_offset = 0;
    downsample_factor = 3; # process 1 out of every this many. for 333Hz use 1. for 1kHz use 3
    roll_forward_on_receive = true;
    publish_head_on_message = false;

    # left foot at zero or body/pelvis at POSE_BDI
    initialization_mode = "zero";
    # basic, slaved_once, slaved_always
    integration_mode = "slaved_always";

    # Assume for this number of tics, velocity measurements are zero at start
    # This is due to coupling between kinematics and orientation
    zero_initial_velocity = 200; # Less than 75 was unstable for Valkyrie, 100 was unstable for Atlas

    # Republish various channels (if reading from a log)
    republish_incoming_poses = false; # republish POSE_VICON and POSE_BDI to the log
    republish_cameras = false;
    publish_diagnostics = false;

    # either foot or talus:
    left_standing_link = "l_foot";
    right_standing_link = "r_foot";

    # filter joint positions: "none", "lowpass", "kalman".
    # was always lowpass when running with bdi stepping. scott may need kalman
    filter_joint_positions = "lowpass";
    joint_process_noise = 0.01; # proc. and obs. variances for kalman filtering ONLY
    joint_observation_noise = 5E-4;

    # filter kinematics when we think contact occurs
    filter_contact_events = true;

    # Contact Classifier Parameters:
    total_force = 1764.0; # atlas v5                           #TODO
    init_contact_mode = "typical"; # "typical" (for toe off and BDI) or "standing" (for mit control, originally)
    standing_schmitt_level = 0.65; # percentage of atlas_weight, 0.65 for a very long time, but needed higher value for standing

    # "typical" contact mode uses FootContactAlt class in SE
    schmitt_low_threshold = 700; # newtons
    schmitt_high_threshold = 790; # newtons
    schmitt_low_delay = 100000; # microseconds
    schmitt_high_delay = 100000; # microseconds

    # Adjust the joint angles using the IHMC torque correction method.
    # adjustment_gain is the spring constant (in radians per Newton-meter of
    # the corresponding joint. The adjustment_gain can be set to inf for
    # joints with no torque deflection. These settings are used both for
    # control and state estimation:
    torque_adjustment = true;

    adjustment_gain = [8000, 10000, 
                       10000, 10000, 10000,
                       8000, 10000, 
                       10000, 10000, 10000];
    
    adjustment_joints = [l_leg_hpx, l_leg_hpy,
                         l_leg_kny, l_leg_aky, l_leg_akx,
                         r_leg_hpx, r_leg_hpy,
                         r_leg_kny, r_leg_aky, r_leg_akx];

    use_controller_input = true;
  }

  legodo_external {

    # Channel Subscribed to:
    channel = "LEG_ODOMETRY_DELTA";

    # All other parameters are taken from legodo block
  }


  # These setting are only used by the leg odometry driven process: se-leg-odometry
  legodo_driven_process {
    # left foot at zero or body/pelvis at POSE_BDI
    initialization_mode = "bdi";
    # basic, slaved_once, slaved_always
    integration_mode = "slaved_always";
  }
}

